# курс https://stepik.org/course/68343/


# ТЕРНАРНЫЙ ОПЕРАТОР
n = 0
print('n = 1' if n == 1 else 'n !=1 ')


# задачка на поиск наибольшего колличества одинаковых символов подряд
coin = input() + 't'
counter = 1
counterMax = []
for i in range(len(coin) - 1):
    if coin[i] == coin[i + 1]:
        counter += 1
    else:
        counterMax.append(counter)
        counter = 1
print(max(counterMax))


# 2.2 шаг 10
# https://stepik.org/lesson/415554/step/10?auth=login&unit=405083
# вывести номера строк, которые содержат комбинация букв a n t o n
n = int(input())

position = []
for i in range(1, n+1):
    counter = 0
    temp = ' '.join(input())
    s = [i for i in temp.split() if i in 'anton']
    for j in 'anton':
        if j in s:
            s = s[s.index(j) + 1:]
            counter += 1
    if counter >= 5:
        position.append(i)

print(*position, sep=' ')


# 2.2 шаг 11
# https://stepik.org/lesson/415554/step/11?auth=login&unit=405083
# поочередно удалять из строки буквы алфавита
s = input()
alph = ['а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я']
s1 = '{0} запретил букву'.format(s)
for i in alph:
    if i in s1:
        print(s1.strip(), i)
        s1 = s1.replace(i, '')
        s1 = s1.replace('  ', ' ')


# bool тип данных
#   False = 0, True = 1
#   оператор and - умножение
#   оператор or - сложение
#   not - отрицание
#   Пример логических выражение:
#   False and True == False, True and True == True, True or False == True, not True == False

# функция bool() приводит типы данных к булевуму по следующей логике:
#   строки: пустая строка — ложь (False), непустая строка — истина (True)
#   числа: нулевое число — ложь (False), ненулевое число (в том числе и меньшее нуля) — истина (True)
#   списки: пустой список — ложь (False), непустой — истина (True)


# Вложенные списки, двойная/тройная индексация
# Работа с вложенными списками принципиально ничем не отличается от работы со списками
# к элементам вложенных списков/самим вложенными спискам можно так - же обращаться по индексам
my_list = ['Python', [10, 20, 30], ['Beegeek', 'Stepik!']]

print(my_list[0][2])       # индексирование строки 'Python', двойная индексация
print(my_list[1][1])       # индексирование списка [10, 20, 30], двойная индексация
print(my_list[2][-1])      # индексирование списка ['Beegeek', 'Stepik!'], двойная индексация
print(my_list[2][-1][-1])  # индексирование строки 'Stepik!', тройная индексация


# при использовании max() на вложенных списках списки сравниваются поэлементно
list1 = [[1, 7], [1, 7, 90], [1, 10]]  # max(list1) == [1, 10]
list2 = [['a', 'b'], ['a', 'b', 'c'], ['c', 'b']]  # max(list2) == [c, b]


# двойная/тройная индексация для обращения к вложенному списку и добавления в него элемента/другого списка
# двойная
list1 = [10, 20, [300, 400, [5000, 6000], 500], 30, 40]
list1[2][2].append(7000)
print(list1)

# тройная
list1 = ['a', 'b', ['c', ['d', 'e', ['f', 'g'], 'k'], 'l'], 'm', 'n']
sub_list = ['h', 'i', 'j']
list1[2][1][2].extend(sub_list)
print(list1)



# 4.2 шаг 12
# https://stepik.org/lesson/416752/step/16?auth=login&unit=406260
# пример задания на работу с вложенными списками
# вывести число: сумму всех чисел списка list1 разделённую на общее количество всех чисел.
list1 = [[1, 7, 8], [9, 7, 102], [102, 106, 105], [100, 99, 98, 103], [1, 2, 3]]
total = 0
counter = 0

for li in list1:
    counter += len(li)
    for i in li:
        total += i
print(total/counter)


# В Python списки – ссылочный тип данных. Конструкция [0] * m возвращает ссылку на список из m нулей.
# Повторение этого элемента n раз создает список из n ссылок на один и тот же список.
# То есть если изменить любой список созданный через подобную конструкцию - изменятся все и остальные
# https://stepik.org/lesson/416753/step/1?auth=login&unit=406261
# 4.3 шаг 1
n, m = int(input()), int(input())

my_list = [[0] * m] * n
my_list[0][0] = 17

print(my_list)


# пример создания вложенного списка с помощью генераторов
n = int(input())
lst = [[i for i in range(1, n + 1)] for i in range(3)]
lst[0][0] = 5
print(lst)



# 4.3 шаг 10
# https://stepik.org/lesson/416753/step/10?auth=login&unit=406261
# Треугольник Паскаля 1
import math
n = int(input())


def pascal(numOfString):
    psclString = [int(math.factorial(numOfString)/(math.factorial(elem)*(math.factorial(numOfString-elem)))) for elem in range(numOfString+1)]
    return psclString


print(pascal(n))



# 4.3 шаг 12
# https://stepik.org/lesson/416753/step/12?auth=login&unit=406261
# упаковка дубликатов, все повторяющиеся символы должны быть записаны как вложенные списки
# основной список - содержит в себе списки с последовательностями одинаковых элементов
def createList(lst):
    lst = lst.split()
    temp = []
    fin = []
    for i in range(len(lst)-1):
        if lst[i] == lst[i+1]:
            temp.append(lst[i+1])
        else:
            temp.append(lst[i])
            fin.append(temp.copy())
            temp.clear()

    for i in lst[-1:]:
        for j in lst[lst.index(i) - 1:]:
            if i == j:
                temp.append(j)
            else:
                temp.append(i)
                fin.append(temp.copy())
                temp.clear()
                break
        break
    if len(temp) != 0:
        fin.append(temp)
    return fin


s = input()


print(createList(s))


# МАТРИЦЫ/методы s.rjust(width, fillchar) и ljust(width, fillchar)
# rjust - выравнивание по правому краю
# width - минимальная длина строки,
# fillchar - символ, которым будет заполняться строка, если len(s) < width

# ljust() - выравнивание по левому краю, парметры как у rjust() параметры
# при выравнивании по левому краю символы строки сдвигаются к левому краю а справа строка заполняется символами fillchar до len(s) == width



# 4.4 шаг 9
# https://stepik.org/lesson/416754/step/9?auth=login&unit=406262
# матрицы, вывести матрицу, потом поменять местами строки со столбцами и вывести
n = int(input())  # кол-во строк
m = int(input())  # кол-во столбцов
matrix = [[input() for i in range(m)] for _ in range(n)]  # создаю матрицу с n строк и m столбцов (вложенный список с n элементов и m элементов внутри самих списков)

# вывожу матрицу
for i in range(len(matrix)):  # запускаю цикл по всем строкам матрицы (элментам верхнего списка)
    print()
    for j in range(len(matrix[i])):  # запускается цикл по всем столбцам (по всем элементам вложенного списка)
        print(matrix[i][j], end=' ')

print()



# инвертирование строк и столбцов
# так - как надо поменять строк и столбцы местами - вывести сначала все первые элементы каждого вложенного списка на одной строке,
# потом все вторые элементы каждого вложенного списка на новой строке и тд
# поэтому при двойной индексации увеличивает первое число - элемент верхнего списка до окончания всех элементов верхнего списка
# потом только начинает увеличиваться второй индекс - номер элемента внутри вложенного цикла (для матриц: увеличивается номер строки до окончания строк, потом номер столбца)
for i in range(len(matrix[0])):  # запускается цикл длиной элемента (длина всех вложенных списков одинаковая)
    print()
    for j in range(len(matrix)):  # запускается цикл по всей матрице
        print(matrix[j][i], end= ' ')  # в двойной индексации увеличиваются сначала элементы верхнего списка до их окончания, потом увеличивается номер выводимого элемента внутри вложенного списка

# в контексте матриц это значит, что мы двигаемся по строкам, выводя сначла первый столбец, пройдя все строки начинается выводить второй столбец и так далее
# и первой строкой новой матрицы будет - первый столбец старой матрицы, так как мы выводим все из первого столбца, потом
# переходим на новую строку и выводим все из второго столбца и так далее



# 4.5 шаг 2
# https://stepik.org/lesson/416755/step/2?auth=login&unit=406263
# Программа должна вывести два числа: номер строки (вложенного списка) и номер столбца (номер элемента вложенного спиcка),
# в которых стоит наибольший элемент таблицы (верхнего списка).

n = int(input())  # кол-во строк
m = int(input())  # кол-во столбцов
matrix = [[int(i) for i in input().split()] for _ in range(n)]  # создаю матрицу (список с глубиной 2)

# записываю в максимум первый элемент первого вложенного списка (первый элемент матрицы)
maximum = max(matrix[0])  # запоминаю максимум из первого вложенного списка (строки матрицы)
ind = 0  # номер элемента внутри верхнего списка (в каком вложенном списке максимум)

for i in range(len(matrix)):  # запускаю цикл по всем вложенным элементам верхнего списка (по всем строкам матрицы)
    if maximum < max(matrix[i]):  # если максимум во вложенном списке (строке матрицы) > чем имеющийся
        maximum = max(matrix[i])  # ставлю максимум найденный элемент
        ind = i  # запоминаю номер вложенного списка, в котором находится элемент (номер строки матрицы)
print(ind, matrix[ind].index(maximum))  # вывожу номер вложенного списка (номер строки матрицы) и первое вхождение этого максимума во вложенный список

matrix[ind].index(maximum)  # конструкция по поиску первого вхождения максимума во вложенном списке (в строке матрицы)



# 4.5 шаг 3
# https://stepik.org/lesson/416755/step/3?auth=login&unit=406263
# Напишите программу, которая меняет местами столбцы в матрице. (поменять во всех вложенных списках пары элементов местами)
n = int(input())
m = int(input())
matrix = [[int(i) for i in input().split()] for _ in range(n)]

i, j = [int(s) for s in input().split()]  # множественное присваивание по элементам списка, список [1, 2], i = 1, j = 2

for l in range(len(matrix)):
    matrix[l][i], matrix[l][j] = matrix[l][j], matrix[l][i]

for k in matrix:
    print(*k)


# 4.5 шаг 8
# https://stepik.org/lesson/416755/step/8?auth=login&unit=406263

# На вход программе подаются координаты коня на шахматной доске в шахматной нотации
# (то есть в виде e4, где сначала записывается номер столбца (буква от a до h, слева направо),
# затем номеру строки (цифра от 11 до 88, снизу вверх)).

# Программа должна вывести на экран изображение доски, разделяя элементы пробелами.

possible_columns = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']  # возможные значения столбца на шахматной доске
deck = [['.' for _ in range(8)] for _ in range(8)]  # создаю шахматную доску (список глубиной 2, где вложенный список - строка доски)

column, row = [i for i in ' '.join(input()).split()]  # получаю позицию коня на доске (множественное присваивание)
column = possible_columns.index(column)  # номер столбца перевожу из буквенного значения в численное

row = 8 - int(row)  # строки на доске идут снизу вверх, то есть в обратном порядке (вложенные списки идут от 6 до 1)

# print(column, row)

for i in range(len(deck)):  # цикл по всем строка доски (по всем элементам верхнего списка)
    for j in range(len(deck[i])):  # цикл по всем столбцам полученной строки (по всем элементам вложенного списка)
        # print(i, j)
        if i == row and j == column:  # если найденная строка и найденный столбец доски равны позиции коня на доске
            # print(i, j)
            deck[i][j] = 'N'  # ставлю коня в найденную позицию

        if (i == row + 2 or i == row - 2) and (j == column + 1 or j == column - 1):  # нахожу позиции, в которые конь может ходить
            deck[i][j] = '*'

        if (j == column + 2 or j == column - 2) and (i == row + 1 or i == row - 1):  # нахожу позиции, в которые конь может ходить - 2
            deck[i][j] = '*'

for i in range(8):  # вывод доски с найденной позицией коня и ячейками, в которые он может ходить
    print(*deck[i])



# 4.5 шаг 9
# https://stepik.org/lesson/416755/step/9?auth=login&unit=406263
# Задание
# Магическим квадратом порядка nn называется квадратная таблица размера n×n, составленная из всех чисел 1, 2, 3, ... n**2
# так, что суммы по каждому столбцу,
# каждой строке
# и каждой из двух диагоналей равны между собой.
# Напишите программу, которая проверяет, является ли заданная квадратная матрица магическим квадратом.

# На вход программе подаётся натуральное число n — количество строк и столбцов в матрице, затем элементы матрицы: n строк, по n чисел в каждой, разделённые пробелами.

n = int(input())  # получаю число n - размер матрицы

matrix = [[int(i) for i in input().split()] for _ in range(n)]  # создаю матрицу размером n

flag = True  # по умолчанию считаем, что матрица - магический квадрат

# числа от 1 до n**2 находятся в матрице
for i in range(1, n**2+1):  # запускается цикл по всем числам, которые должны быть в матрице
    # if str(i) in ''.join(str(k) for k in matrix):  # каждое число проверяется на вхождение в матрицу, через генератор, не совсем понимаю, как работает

    # каждое число проверяется на вхождение в матрицу, создаю новый список генератором на основе списка глубиной 2 (матрицы),
    # запуская цикл по элементам верхнего списка for lst in matrix (типы элементов - list), затем по элементам внутреннего списка for i in lst (типы элементов int)
    # полученный int вношу в свой список
    if i in [int(i) for lst in matrix for i in lst]:
        pass
    else:
        flag = False  # если число не вошло - считаем, что матрица не магический квадрат
        break

if flag:  # если все необходимые числа вошли в матрицу
    matrix_elem_sum = sum(matrix[0])  # переменная хранит суммы элементов вложенных списков
    sub_summ = 0  # суммы элементов побочной диагонали
    main_summ = 0  # суммы элементов главной диагонали

    for i in range(len(matrix)):

        # если суммы строк совпадают
        if matrix_elem_sum == sum(matrix[i]):  # если сумма элементов очередного вложенного списка - совпадает с другими
            pass
        else:
            flag = False  # иначе, считаем, что матрица не магический квадрат

        column_matrix_elem_sum = 0  # счетчик элементов суммы элементов столбца внутри матрицы (i-ых элементов всех вложенных списков)
        for j in range(len(matrix[i])):
            column_matrix_elem_sum += matrix[j][i]  # прохожусь по всем i-м элементам каждого вложенного списка (по элементу каждой строки iго столбца)

            # суммы главной и побочной диагоналей
            if i == j:  # если элемент лежит на главной диагонали
                main_summ += matrix[i][j]  # увеличиваю счетчик
            if j == n - i - 1:  # если элемент лежит на побочной диагонали
                sub_summ += matrix[i][j]

        # если суммы столбцов совпадают
        if i == 0:  # для первого столбца матрицы (для нулевых элементов всех воженных списков) нет столбца для сравнения, делаю исключения на первой итерации цикла
            prev = column_matrix_elem_sum  # запоминаю сумму элементов первого столбца (суммы iых элемнтов всех вложенных списков)
        if column_matrix_elem_sum == prev:  # на следующих итерациях сравниваю суммы остальных столбцов с суммой первого (суммых iых элементов с суммой нулевых элементов всех вложенных списков)
            pass
        else:
            flag = False

    if flag and main_summ == sub_summ:  # если считаем матрицу магическим квадратом и суммы элементов основной и побочной диагонали - равны
        print('YES')  # выводим, что матрица магический квадрат
    else:
        print('NO')

else:
    print('NO')



# 5.1 шаг 3
# https://stepik.org/lesson/416759/step/3?unit=406267
# Задание из экзамена
# Траспонированная матрица (столбцы поменены местами со строками)
n = int(input())
matrix = [[int(i) for i in input().split()] for _ in range(n)]

temp = [[matrix[j][i] for j in range(len(matrix[i]))] for i in range(len(matrix))]

for li in temp:
    print(*li)

# КОРТЕЖИ
# Списки – изменяемые коллекции, строки – неизменяемые последовательности Unicode символов.
# В Python имеются и неизменяемые последовательности содержащие,
# в отличие от строк, абсолютно произвольные данные. Такие коллекции называются кортежами (tuple, читается "тюпл").

# Кортежи поддерживают те же операции, что и списки, за исключением изменяющих содержимое.
numbers = (1, 2, 3)

# index()
numbers.index(1)  # 0

# count()
numbers.count(2)  # 1

# len()
len(numbers)  # 3

# sum()
sum(numbers)  # 6

# min()
min(numbers)  # 1

# min()
max(numbers)  # 3

# Кортежи поддердивают срезы и индексирование
print(numbers[0])  # 1
print(numbers[1:2])  # 2, 3

# распаковка кортежа
print(*numbers)

# str()
print(str(numbers))  # (1, 2, 3)


# join()
numbers = ('First', 'Second', 'Third')
print('-'.join(numbers))  # First-Second-Third

# сравнение кортежей
print((1, 8) == (1, 8))  # True
print((1, 8) != (1, 10))  # True
print((1, 9) < (1, 2))  # False
print((2, 5) < (6,))  # True
print(('a', 'bc') > ('a', 'de'))  # False


# Встроенная функция list() может применяться для преобразования кортежа в список.
number_tuple = (1, 2, 3, 4, 5)
number_list = list(number_tuple)  # [1, 2, 3, 4, 5]

# Встроенная функция tuple() может применяться для преобразования списка в кортеж.
str_list = ['один', 'два', 'три']
str_tuple = tuple(str_list)  # ('один', 'два', 'три')

# с помощью преобразования кортежа в список можно внести изменения в кортеж
writer = ('Лев Толстой', 1827)
a = list(writer)
a[1] = 1828
writer = tuple(a)  # ('Лев Толстой', 1828)


# 6.2 шаг 14
# https://stepik.org/lesson/444816/step/14?unit=434982
# в переменных city_year, city_name содержится год основания города и его название соответсвенно
# переменная city должна содержать кортеж названия города и даты его основания
city_name = input()
city_year = int(input())
city = (city_name, city_year)  # кортеж можно сделать через (x, y)
print(city)


# чтобы отсортировать список можно воспользовать sorted() - не путать с sort()
not_sorted_tuple = (34, 1, 8, 67, 5, 9, 0, 23)
sorted_tuple = tuple(sorted(not_sorted_tuple))  # sorted() возвращает отсортрованный список на основании кортежа
print(sorted_tuple)  # (0, 1, 5, 8, 9, 23, 34, 67)


# изменение списков пример
poet_data = ('Пушкин', 1799, 'Санкт-Петербург')  # неизменяемый кортеж с 3мя элементами

poet_data = list(poet_data)  # перевожу кортеж в список
poet_data[2] = 'Москва'  # изменяю элемент в списки, который создан на основании кортежа

print(tuple(poet_data))  # перевожу измененные данные в тип кортежей



# 6.3 шаг 9
# https://stepik.org/lesson/443990/step/9?unit=434154
# На вход программе подается натуральное число nn, далее следует nn строк с фамилией школьника и его оценкой на каждой из них.
# Программа должна вывести сначала все введённые строки с фамилиями и оценками учеников в том же порядке.
# Затем следует пустая строка, а затем выводятся строки с фамилиями и оценками хорошистов и отличников (в том же порядке).

n = int(input())  # получаю кол-во вводимых строк
grades = [tuple(input().split()) for _ in range(n)]  # из каждой строки делаю кортеж из фамилии и оценки, запуская генератор с кол-вом итераций  == кол-во строк

well_grades = [tu for tu in grades if int(tu[1]) >= 4]  # создаю список кортежей с хорошистами/отличниками, на основе списка с кортежами всех оценок


for tu in grades:  # запускаю цикл по всем оценкам
    print(*tu)  # запускаю цикл по списку кортежей со всеми оценками, вывожу распакованный кортеж

print()

for tu in well_grades:  # запускаю цикл по списку кортежей с хорошими оценками
    print(*tu)  # распаковываю полученный кортеж кортеж



# 6.3
# РАСПАКОВКА КОРТЕЖЕЙ
# https://stepik.org/lesson/443990/step/10?unit=434154
# ПРИ РАСПАКОВКЕ КОРТЕЖЕЙ МОЖНО ИСПОЛЬЗОВАТЬ ПЕРЕМЕННУЮ, СОДЕРЖАЩУЮ НЕСКОЛЬКО ЗНАЧЕНИЙ
tup = ('a', 'b', 'c')
a, *any = tup  # *any содержит все значений из кортежа tup, которые не были присвоены после "a" и ЯВЛЯЕТСЯ СПИСКОМ
# такие переменные могут быть пустыми или иметь одно значение и все равно будут спискам

a = 1,  # не распаковка, а просто присвоение
b, = 1,  # распаковка
# распаковываться могут любые последовательности (списки, строки, кортежи)


# строковый метод partition()
# partition() принимает на вход один аргумент sep, разделяет строку при первом появлении sep и возвращает кортеж, состоящий из трех элементов:
#    часть перед разделителем, сам разделитель и часть после разделителя.
# Если разделитель не найден, то кортеж содержит саму строку, за которой следуют две пустые строки.

s1 = 'abc-de'.partition('-')  # ('ab', '-', 'de')
s2 = 'abc-de'.partition('.')  # ('abc-de', '', '')
s3 = 'abc-de-fgh'.partition('-')  # ('abc', '-', 'de-fgh')


# МНОЖЕСТВА
# документация https://docs.python.org/3/library/stdtypes.html#set
# полезная статья на хабре https://habr.com/ru/post/516858/
# поддерживают
len()
sum()
min()
max()
sorted()  # возвращает отсортированный список, не путать со списочным методом sort()
in

numbers.add(1)  # добавляет элемент 1 в множество
numbers.remove('a')  # удаляет элемент 'a' из множества, если элемента нет - выводится ошибка
numbers.discard('a')  # удаляет элемент 'a' из множества без генерации ошибки, если элемента нет
numbers.pop()  # удаляет и возвращает случайный элемент из множества, если множество пустое - выводится ошибка
numbers.clear()  # очищает множество

numbers1.union(numbers2)  # объединения двух множеств, возвращает множество, которое входят все элементы numbers1 и numbers2 (cross join), может принимать несколько аргументов
# эквивалентно "numbers1 | numbers2".
numbers1.update(numbers2)  # изменяет текущее множество, объяденяя его с numbers2 по всем элементам (cross join)
# эквивалентно "numbers1 |= numbers2".

numbers1.intersection(numbers2)  # объединения двух множеств, возвращает множество, элементы которого принадлежат одновременно numbers1 и numbers2 (join),
# может принимать несколько аргументов, эквивалентно "numbers1 & numbers2".
numbers1.intersection_update(numbers2)  # изменяет текущее множество, объяденяя его с numbers2 по элементам которые находятся в обоих множествах (join)
# эквивалентно "numbers1 &= numbers2".

numbers1.diffrence(numbers2)  # возвращает множество, на основе numbers1 без элементов, которые есть в numbers2 (left join),
# может принимать несколько аргументов, эквивалентно "numbers1 - numbers2"
numbers1.difference_update(numbers2)  # изменяет текущее множество, удаляя элементы, которые есть в numbers2
# эквивалентно "numbers1 -= numbers2"

numbers1.symmetric_difference(numbers2)  # возвращает множество, с элементами, которые различны в numbers1 и numbers2 (cross join where number1 is 1 or numbers2 is 1)
# эквивалентно "numbers1 ^ numbers2"
numbers1.symmetric_difference_update(numbers2)  # изменяет numbers1, добавляя элементы из numbers2, которых нет в numbers1
# эквивалентно "numbers1 ^= numbers2".

numbers1.issubset(numbers2)  # возвращает True если numbers1 подмножество numbers2,
# эквиваленто numbers1 <= numbers2

numbers1.issuperset(numbers2)  # возвращает True если numbers1 надмножество numbers2,
# эквиваленто numbers1 >= numbers2

numbers1.isdisjoint(numbers2)  # для определения наличия общих элементов, если общие элементы есть - возвращается True


|, &, -, ^  # операции над множествами -  union, intersection, difference, symmetric_difference соответственно


# Методы множеств могу принимать как аргумент не только список, но и любые итерируемые объекты (список, кортеж, строку)

# Индексация и срезы не работают для множеств (элементы не упорядочены)
# Операия конкатенации и умножения так - же недоступна для множеств

# Все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
# Множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
# Элементы множества должны относиться к неизменяемым типам данных;
# Хранящиеся в множестве элементы могут иметь разные типы данных.

# Элементы множества могут принадлежать любому неизменяемому типу данных, быть числами, строками, кортежами!!!
# Если мы не изменяли множество, порядок обхода элементов при помощи цикла for не изменится.


# создание множества
numbers = {2, 4, 6, 8, 10}

languages = {'Python', 'C#', 'C++', 'Java'}
set('aabbccdd') # {'a', 'b', 'c', 'd'}


# ГЕНЕРАТОРЫ МНОЖЕСТВ, FROZENSET
# синтаксис - {выражение for переменная in последовательность}
digits = {int(c) for c in input()}

# Условия в генераторах множеств
digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()}  # генератор множества с условием

digits = {int(d) if d.isdigit() else d for d in 'abcd12ef78ghj90'}  # генератор с условием, конструкция if-else надо включать перед циклом

# встроенная функция sorted(numbers, reverse = True) имеет параметр reverse, который может отсортировать список в обратном порядке


# множество (тип frozenset) – неизменяемая версия обычного множества (тип set).
# Будучи изменяемыми, обычные множества не могут быть элементами других множеств.
# Замороженные множества являются неизменяемыми, а значит могут быть элементами других множеств.

frozenset()  # для создания неизменяемого множества, принимает в качестве аргумента - итерируемый объект

# 8.4 шаг 16
# https://stepik.org/lesson/481525/step/16?auth=login&thread=solutions&unit=472630
# получаю строку из трех слов, если в словах использован одинаковый набор букв - ЙЕС, иначе НОУ
word1, word2, word3 = input().split()  # введенной строку перевожу в список и использую множественное присваивание

same_letters_flag = True
if set(word1) == set(word2) == set(word3):
    print('YES')
else:
    print('NO')


# 8.5 шаг 12
# https://stepik.org/lesson/445791/step/12?auth=login&unit=436052
# на вход поступает число - кол-во слов, которые будут поданы, программа
# должны будет вывести кол-во уникальных букв во всех словах
n = int(input())
words = [input().lower() for _ in range(n)]  # создаю список со всеми словами

print(len(set(''.join(words))))  # список перевожу в строк (''.join), перевожу в множество (set) и вывожу его длину (len)


# 8.5 шаг 14
# https://stepik.org/lesson/445791/step/14?auth=login&unit=436052
# На вход программе подается строка текста, содержащая числа, разделенные символом пробела.
# Для каждого числа выведите слово YES (в отдельной строке),
# если это число ранее встречалось в последовательности или NO, если не встречалось.

# вариант 1 - без множества
numbers = [int(i) for i in input().split()]

for i in range(len(numbers)):
    if numbers[i] in numbers[:i]:
        print('YES')
    else:
        print('NO')


# вариант 2 - с множеством
numbers = [int(i) for i in input().split()]
st = set()

for i in numbers:
    if i not in st:
        print('NO')
        st.add(i)
    else:
        print('YES')



# 8.6 шаг 14
# https://stepik.org/lesson/482377/step/14?auth=login&unit=473680
# На вход программе подаются две строки текста, содержащие числа.
# Напишите программу, которая выводит все числа в порядке возрастания, которые есть как в первой строке, так и во второй.

rows = [set([int(i) for i in input().split()]) for _ in range(2)]  # запускаю генератор с двумя итерациями,
# в каждой итерации введенная строка разделяется на список и поэлементо переводится в int, полученный список переводится в множество по окончанию итерации

print(*sorted(rows[0].intersection(rows[1])))  # вводится совпадение из двух списоков, отсортированное по возрастанию


# 8.7 шаг 8
# https://stepik.org/lesson/483114/step/8?auth=login&thread=solutions&unit=474427
# На вход программе подаются два числа. Напишите программу, определяющую, есть ли в данных числах одинаковые цифры.
number1, number2 = [set(input()) for _ in range(2)]  # создаю множества из цифр, которые получаю на вход

print(('YES', 'NO')[number1.isdisjoint(number2)])  # вывожу YES или NO из кортежа, выбирай индекс по True == 1 или Flase == 0, True/False получаю из метода


# 8.7 шаг 10
# https://stepik.org/lesson/483114/step/10?auth=login&unit=474427
# На вход программе подаются оценки трех учеников, разделенные символом пробела (оценки каждого ученика на отдельной строке).
# Напишите программу, которая выводит множество оценок, которые есть и у первого и у второго учеников, но которых нет у третьего ученика.

grades = [set([int(i) for i in input().split()]) for _ in range(3)]  # запускаю генератор с тремя итерациями, в каждой итерации создаю список, в нем запускаю цикл введенной строке
# тип полученного элемента строки меняю на int, когда список чисел сформирован - создаю на его основании множество, в итоге получается список из множеств, внутри которых числа

print(*sorted((grades[0].intersection(grades[1])).difference(grades[2]), reverse = True))


# 8.7 шаг 11
# https://stepik.org/lesson/483114/step/11?auth=login&unit=474427
# Напишите программу, которая выводит множество оценок, имеющихся у учеников, которые встречаются не более, чем у двух из указанных учеников.
grades = [set([int(i) for i in input().split()]) for _ in range(3)]

grades_except = set().union(*grades).difference(grades[0].intersection(grades[1], grades[2]))  # использую объединения множеств всех оценок, получаю все оценки -
# распоковкой списка множств *grades, так - же распаковывать можно и срезы, например использовать конструкцию *grades[0:2]

print(*sorted(grades_except))


# 8.7 шаг 13
# https://stepik.org/lesson/483114/step/13?auth=login&unit=474427
# Напишите программу, которая выводит множество оценок, не встречающихся ни у одного из трех учеников.
grades = [set([int(i) for i in input().split()]) for _ in range(3)]

# проверяю difference чисел (0, ... 11) c множеством, созданом на основе распакованного списка множеств всех оценок
grades_except = set(range(11)).difference(set().union(*grades))  # создаю множество st.union(*lst), соединяя пустое множество set() с распакованным списком *grades,
# содержащим множества всех оценок каждого ученика

print(*sorted(grades_except))


numbers = {1, 2, 3}
print(numbers+numbers)



# 9.2 шаг 9
# https://stepik.org/lesson/445985/step/9?unit=470426
# Каждый ученик, обучающийся в онлайн-школе BEEGEEK изучает либо математику, либо информатику, либо оба этих предмета. У руководителя школы есть списки изучающих каждый предмет.
# Напишите программу, позволяющую руководителю выяснить, сколько учеников изучает только один предмет.

# На вход программе в первых двух строках подаются числа m и n – количества учеников, изучающих математику и информатику соответственно.
# Далее идут m строк — фамилии учеников, которые изучают математику и n строк с фамилиями учеников, изучающих информатику.

# получаю - кол-во студентов, занимающихся математикой/информатикой
math_amount = int(input())
inf_amount = int(input())

# по кол-во студентов создаю множетсво с фамилиями студентов
math_students = {input() for _ in range(math_amount)}
inf_students = {input() for _ in range(inf_amount)}

# нахожу множество учеников которые занимаются только один предметом (все студенты МИНУС пересечения учеников в обоих группах)
only_math_students = math_students - math_students.intersection(inf_students)
only_inf_students = inf_students - inf_students.intersection(math_students)

# конструкция выражение if условие else выражение (тернарный оператор) НЕ В ГЕНЕРАТОРЕ
print(len(only_math_students) + len(only_inf_students) if len(only_math_students) + len(only_inf_students) != 0 else 'NO')


# СЛОВАРИ
# хабр https://habr.com/ru/post/432996/
# изменяемый тип данных
# В рамках одного словаря каждый ключ уникален
# В случае некорректного указания элементов при создании словаря выпадет ошибка, например:
info_list = [('name', 'Timur', 1)] - ОШИБКА, ТРИ ЭЛЕМЕНТА ВО ВЛОЖЕННОМ КОРТЕЖЕ
info_list = [('name', 'Timur'), 1]  - ОШИБКА, ВТОРОЙ ЭЛЕМЕНТ - НЕ КОРТЕЖ И НЕ СПИСОК
info_list = [('name', 'Timur'), (1,)] - ОШИБКА, ВТОРОЙ ЭЛЕМЕНТ ИМЕЕТ ОДИН ЭЛЕМЕНТ
# Ключи словаря должны быть уникальными
# Ключи должны быть неизменяемым типом данных (число, строка, кортеж, frozenset())
# Значения могут относиться к любому типу данных, их тип данных произволен  (список, множество, словарь)


# РАБОТА СО СЛОВАРЯМИ
# Обращение по индексу и срезы недоступны для словарей.
#  Операция конкатенации + и умножения на число * недоступны для словарей.
# При сравнении словарей у них сравниваются все связки "ключ: значение"

len()  # подсчитывает кол-во элементов в словаре
sum()  # вычисляет сумму числовых КЛЮЧЕЙ СЛОВАРЯ
min()  # находит максимальны КЛЮЧ словаря
max()  # находит минимальный КЛЮЧ словаря
sorted()  # возвращает отсортированный СПИСОК КЛЮЧЕЙ
in  # проверяет входит ли КЛЮЧ в словарь (работает быстрее, чем в других типах данных)

keys()  # возвращает список ключей всех элементов словаря my_dict.keys()
values()  # возвращает список значений всех элементов словаря. my_dict.values()
items()  # возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение).
# методы items(), keys(), values() возвращают списки с типом dict_list, для использование методов списков их нужно преобразовать в list,
# например через встроенную функцию list()

get()  # my_dict.get(key, string)  позволяет получить значение ключа key из словаря my_dict, если такого ключа нет - возвращает string
update()  # my_dict.update(my_dict1) конкатенация двух словарей, при совпадении ключей - сохраняется значения словаря аргумента (my_dict1)
setdefault()  # my_dict.set_default(key, default_value) позволяет получить значения ключа key из словаря, если ключа нет - создает и устанавливает default_Value (второй аргумент)
del my_dict[key]  # оператор работает для словарей, если такого ключа нет - ошибка
pop()  # метод my_dict.pop(key, value) удаляет из my_dict элемент с ключем key и возвращает его знаечние. Если ключа нет, возвращается Value
popitem()  # метод my_dict.popitem() удаляет последний добавленный элемент и возвращает его значение в виде кортежа (ключ, значение )
clear()  # метод my_dict.clear() удаляет все элементы из словаря
copy()  # метод my_dict.copy() cвозвращает копию словаря my_dict



# ГЕНЕРАТОР СЛОВАРЯ
# без условия if
dct = {key: value for i in example}  # {ключ: значение for переменная in последовательность}

# с условием if
dct = {key: value for _ in example if key > 1}  # {ключ: значение for переменная in последовательность if выражение}

# с условием if-else для значения
dct = {key: (value if value > 1 else not_value) for _ in example}  # {ключ: (значение if выражение else не_значение) for переменная in последовательность}

# с условием if-else для ключа
dct = {(key if key > 1 else not_key): value for _ in example}  # {(ключ if выражение else не_ключ): значение for переменная in последовательность}



*my_dict  # возвращает коллекцию ключей словаря


# для вывода элементов словаря используется
print(mydict)

# для вывода ключей словаря
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key in capitals:
    print(key)

# для вывода значений словаря
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key in capitals:
    print(capitals[key])

# для создания словаря
# создание пустого словаря, оба способа идентичны
empty_dict = {}  # {}
empty_dict_1 = dict()  # {}

# создание словаря напрямую (литерально)
info = dict(name = 'Timur', age = 28, job = 'Teacher')  # {'name': 'Timur', 'age': 28, 'job': 'Teacher'}

# создание словаря на основании списка кортежей
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей
info_dict = dict(info_list)  #  {'name': 'Timur', 'age': 28, 'job': 'Teacher'}

# создание словаря на основании кортежа списков
info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков
info_dict_1 = dict(info_tuple)  #  {'name': 'Timur', 'age': 28, 'job': 'Teacher'}

# для создания словаря с одинаковыми значениями каждого ключа
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed')  # {'name': 'Missed', 'age': 'Missed', 'job': 'Missed'}


# для обращения к элементу словаря:
mydict = {'first': '1'}
print(mydict['first'])  # 1

# Изменение значений, добавление элементов
info = {'name': 'Sam', 'age': 28, 'job': 'Teacher'}
info['name'] = 'Timur'                    # изменяем значение по ключу name
info['email'] = 'timyr-guev@yandex.ru'    # добавляем в словарь элемент с ключом email

# 10.2 шаг 12
# https://stepik.org/lesson/488830/step/12?unit=480066
# вывести имена людей, у которых нет информации о email (ключа email может не быть)
users = [{'name': 'Todd', 'phone': '551-1414', 'email': 'todd@gmail.com'},
         {'name': 'Helga', 'phone': '555-1618'},
         {'name': 'Olivia', 'phone': '449-3141', 'email': ''},
         {'name': 'LJ', 'phone': '555-2718', 'email': 'lj@gmail.net'},
         {'name': 'Ruslan', 'phone': '422-145-9098', 'email': 'rus-lan.cha@yandex.ru'},
         {'name': 'John', 'phone': '233-421-32', 'email': ''},
         {'name': 'Lara', 'phone': '+7998-676-2532', 'email': 'g.lara89@gmail.com'},
         {'name': 'Alina', 'phone': '+7948-799-2434'},
         {'name': 'Robert', 'phone': '420-2011', 'email': ''},
         {'name': 'Riyad', 'phone': '128-8890-128', 'email': 'r.mahrez@mail.net'},
         {'name': 'Khabib', 'phone': '+7995-600-9080', 'email': 'kh.nurmag@gmail.com'},
         {'name': 'Olga', 'phone': '6449-314-1213', 'email': ''},
         {'name': 'Roman', 'phone': '+7459-145-8059'},
         {'name': 'Maria', 'phone': '12-129-3148', 'email': 'm.sharapova@gmail.com'},
         {'name': 'Fedor', 'phone': '+7445-341-0545', 'email': ''},
         {'name': 'Tim', 'phone': '242-449-3141', 'email': 'timm.ggg@yandex.ru'}]

# создаю список имен на основании полученного словаря, если значение email пустое или его нет в словаре
res = [i['name'] for i in users if 'email' not in i.keys() or i['email'] == '']

print(*sorted(res))


# 10.2 шаг 13
# https://stepik.org/lesson/488830/step/13?unit=480066
# заменит все цифры в числе на литеральные значения
d = {
    0: "zero",
    1: "one",
    2: "two",
    3: "three",
    4: "four",
    5: "five",
    6: "six",
    7: "seven",
    8: "eight",
    9: "nine"
}

n = int(input())

for i in str(n):
    print(d[int(i)], end = ' ')


# 10.2 шаг 15
# https://stepik.org/lesson/488830/step/15?unit=480066
# на вход поступает сообщение, которое нужно напечатать, вывести последовательность клавиш которые нужно нажать для этого сообщения
keyboard = {
    "0": [" "],
    "1": [".", ",", "?", "!", ":"],
    "2": ["A", "B", "C"],
    "3": ["D", "E", "F"],
    "4": ["G", "H", "I"],
    "5": ["J", "K", "L"],
    "6": ["M", "N", "O"],
    "7": ["P", "Q", "R", "S"],
    "8": ["T", "U", "V"],
    "9": ["W", "X", "Y", "Z"]
}

n = input()

for i in n.upper():  # запускаю цикл по всей введенной строке
    if i in [k for j in keyboard.values() for k in j]:  # проверяю, есть ли символов на клавиатуре
        for j in keyboard.values():  # запускаю цикл по всем значениям словаря (все значения - списки), чтобы найти, на какой кнопке находится нужный символ
            for k in j:  # запускаю цикл по всем элементам списка, чтобы вычислить на какой позиции в кнопке находится символ
                if i == k:  # если символ найден
                    keyboard_key = list(keyboard.values()).index(j)  # запоминаю кнопку, на которой он находится (перевожу dict_list в list для использования index())
                    keyboard_key_counter = list(j).index(k) + 1  # и его номер на кнопке (перевожу dict_list в list для использования index())
        print(str(keyboard_key) * keyboard_key_counter, end = '')  # вывожу, какую кнопку и сколько раз нужно нажать, чтобы напечать символ


# 10.2 шаг 16
# https://stepik.org/lesson/488830/step/16?unit=480066
# На вход программе подается одна строка – текстовое сообщение.
letters = [c for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789']
morse = ['.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..', '-----', '.----', '..---', '...--', '....-', '.....', '-....', '--...', '---..', '----.']

letters_morse = dict(zip(letters, morse))  # функция zip() для создания словаря на основании двух списков. zip(list1, list2)

message = input()

for i in message.upper():
    if i in letters_morse.keys():
        print(letters_morse[i], end=' ')


# 10.3 шаг 12
# https://stepik.org/lesson/446696/step/12?unit=437002
# на основании строки создать словарь с ключами - символами строки и значениями - кол-во вхождений этих символов в строку
text = 'footballcyberpunkextraterritorialityconversationalistblockophthalmoscopicinterdependencemamauserfff'
text_unic = set(text)  # создаю множество на основе строки (только уникальные символы)
result = {}  # пустой словарь

for i in text_unic:  # запускаю цикл по всем уникальным символам строки
    result.setdefault(i, text.count(i))  # в словарь result добалвляю ключ-символ строки и ставлю ему значение - кол-во вхождений в строку


# 10.3 шаг 13
# https://stepik.org/lesson/446696/step/13?unit=437002
# вывести слово, которое встречается наименьшее кол-во слов, если таки слов несколько, вывести в первой в отсортированном порядке
s = 'orange strawberry barley gooseberry apple apricot barley currant orange melon pomegranate banana banana orange barley apricot plum grapefruit banana quince strawberry barley grapefruit banana grapes melon strawberry apricot currant currant gooseberry raspberry apricot currant orange lime quince grapefruit barley banana melon pomegranate barley banana orange barley apricot plum banana quince lime grapefruit strawberry gooseberry apple barley apricot currant orange melon pomegranate banana banana orange apricot barley plum banana grapefruit banana quince currant orange melon pomegranate barley plum banana quince barley lime grapefruit pomegranate barley'

res = {i: s.count(i) for i in set(s.split())}  # ГЕНЕРАТОР СЛОВАРЕЙ {key: value for key, value in query}

value_of_max = max(res.values())  # запоминаю максимальное значение из словаря
max_words = sorted([key for key in res if res[key] == value_of_max])  # создаю список, куда включа ключи, значение которых равно максимальному, сортирую по возрастанию


print(max_words[0], value_of_max)  # вывожу первое слово из наиболее встречающихся (в отсортированном порядке)


# 10.3 шаг 14
# https://stepik.org/lesson/446696/step/14?unit=437002
# Вам доступен список pets, содержащий информацию о собаках и их владельцах.
# Каждый элемент списка – это кортеж вида (кличка собаки, имя владельца, фамилия владельца, возраст владельца).
# выводится словарь: владелец: собака (у одного владельца может быть несколько собак)
pets = [('Hatiko', 'Parker', 'Wilson', 50),
        ('Rusty', 'Josh', 'King', 25),
        ('Fido', 'John', 'Smith', 28),
        ('Butch', 'Jake', 'Smirnoff', 18),
        ('Odi', 'Emma', 'Wright', 18),
        ('Balto', 'Josh', 'King', 25),
        ('Barry', 'Josh', 'King', 25),
        ('Snape', 'Hannah', 'Taylor', 40),
        ('Horry', 'Martha', 'Robinson', 73),
        ('Giro', 'Alex', 'Martinez', 65),
        ('Zooma', 'Simon', 'Nevel', 32),
        ('Lassie', 'Josh', 'King', 25),
        ('Chase', 'Martha', 'Robinson', 73),
        ('Ace', 'Martha', 'Williams', 38),
        ('Rocky', 'Simon', 'Nevel', 32)]

# способ 1
# result = {(i[1:]): list() for i in pets}  # способ с генератором, ключем делаю владельца (фамилия имя возраст)

# for i in pets:  # запускаю цикл по всему списку собак и владельцев
#     for j in result:  # запускаю цикл по всем владельцам
#       if i[1:] == j:  # если в словаре найден владелец собаки из списка
#            result[j].append(i[0])  # к списку собак владельца - добавляю кличку собаки


# способ 2
result = {}

for i in pets:  # цикл по всему списку собак
    result.setdefault(i[1:], []).append(i[0])  # получаю значение владельца i[1:] из словаря, если владелец есть в словаре - возвращается список его собак и к нему прибавляется найденная собака
    # если значение в словаре есть - тогда получаю существующий список и прибавля к нему найденную кличку собаки

print(result)


# 10.3 шаг 16
# https://stepik.org/lesson/446696/step/16?unit=437002
# Напишите программу, которая исправляет их так, чтобы в результирующей строке не было дубликатов.
# Для этого необходимо прибавлять к повторяющимся идентификаторам постфикс _n,
# где n – количество раз, сколько такой идентификатор уже встречался
n = input()

n_unic_list = list()  # создаю пустой список, куда буду добавлять элементы, делая их уникальными
temp = {}  # пустой словарь
for i in n.split():  # запускаю цикл по всем символам исходной строки
    if i not in n_unic_list:  # если символ встречается впервые
        n_unic_list.append(i)  # добавляю элемент в список
        # в словарь счетчик элементов добавляю "слово: кол-во раз, сколько оно встретилось"
        temp[i] = temp.get(i, 0) + 1  # получаю значение из temp по ключу i, если его нет - возвращается 0, к нему прибавляю 1 (элемент встретился первый раз)
    else:  # если символ уже есть в списке
        n_unic_list.append(f'{i}_{temp[i]}')  # прибавляю элемент i и добавляю уникальный идентификатор-счетчик того, сколько раз элемент встретился (беру значение из словаря счетчика)
        temp[i] = temp.get(i) + 1  # в словаре-счетчике слов прибавляю 1 (элемент снова встретился в строке), где ключ - слово, которое встретилось


print(*n_unic_list)  # вывожу список слов, с добавленными уникальными идентификаторами (кол-во повторений символа)



# 10.4 шаг 2
# https://stepik.org/lesson/488831/step/2?unit=480067
# проверить, совпадает ли набор букв из слова 1 с набором букв из слова 2
n = input()
n1 = input()

n_dict = {i: n.count(i) for i in n}  # создаю словарь из слова 1
n1_dict = {i: n1.count(i) for i in n1}  # создаю словарь из слова 1

if n_dict == n1_dict:  # СРАВНИВАЮ СЛОВАРИ
    print('YES')
else:
    print('NO')


# 10.4 шаг 4
# https://stepik.org/lesson/488831/step/4?unit=480067
# На вход программе подается количество пар синонимов n. Далее следует nn строк, каждая строка содержит два слова-синонима.
# После этого следует одно слово, синоним которого надо найти.
n = int(input())

sin = dict([tuple(input().split()) for _ in range(n)])  # создаю словарь из пар слово: синоним
sin_reverse = dict(zip(sin.values(), sin.keys()))  # создаю копию словаря 1, меняю пары, синоним: слово

find_sin = input()  # получаю слово, синоним которого надо найти

# если полученное слово найдено в ключах словаря 1 - вывожу его синоним, иначе нахожу его в словаре 2 (использую тернарный оператор)
print(sin[find_sin] if sin.get(find_sin, False) is not False else sin_reverse[find_sin])



# 10.4 шаг 6
# https://stepik.org/lesson/488831/step/6?unit=480067
# В первой строке задано одно целое число n — количество номеров телефонов, информацию о которых Тимур сохранил в телефонной книге.
# В следующих n строках заданы телефоны и имена их владельцев через пробел.
# В следующей строке записано целое число m — количество поисковых запросов от Тимура.
# В следующих m строках записаны сами запросы, по одному на строке. Каждый запрос — это имя друга, чьи телефоны Тимур хочет найти.
n = int(input())
temp = [tuple(input().split()) for _ in range(n)]  # записываю номера телефонов каждого ка кортеж (имя, номер)

phone_numbers = dict()
for tu in temp:  # цикл по всему списку кортежей (имя, телефон)
    # создаю словарь {имя: [телефон1, телефон2]}
    phone_numbers.setdefault(tu[1], []).append(tu[0])  # ищу имя (ключ) в словаре, если нахожу - получаю список имеющихся телефонов, если не нахожу устанавливаю пустой список для этого имени
    # для обоих вариантов в итоге прибавляю номер телефона из кортежа

n1 = int(input())
temp1 = [input().capitalize() for _ in range(n1)]  # записываю все запросы (имена, чьи телефоны надо вывести)

for i in temp1:  # цикл по всем именам
    if i in phone_numbers:
        print(*phone_numbers[i])  # вывожу список телефонов по ключу-имени
    else:
        print('абонент не найден')  # если такого ключа в словаре нет вывожу абонент не найден


# 11.2 шаг 5
# https://stepik.org/lesson/492141/step/5?unit=483447
# Функция должна принимать список словарей и возвращать словарь,
# Каждый ключ которого содержит множество (тип данных set) уникальных значений собранных из всех словарей переданного списка
def merge(values):  # values - это список словарей
    # генератор проходится по всем словарям, забирая все ключи вложенных словарей, а значениями делает множества, проходя по всем словарям и забирая все значения этого ключа из всех вложенных словарей
    return {key: {dct1[key] for dct1 in values if key in dct1} for dct in values for key in dct}



# 11.2 шаг 7
# https://stepik.org/lesson/492141/step/7?unit=483447
# На вход программе подается число
# n — количество строк в базе данных о продажах интернет-магазина. Далее следует
# n строк с записями вида "покупатель товар количество",
# где покупатель — имя покупателя (строка без пробелов), товар — название товара (строка без пробелов), количество — количество приобретенных единиц товара (натуральное число).

# функция для проверки, была ли уже данная позиция у покупателя
def is_position_unic(old_positions, new_position):
    if old_positions is False:  # если покупателя - нет, значит и позиции не было
        return True  # позиция уникальна
    if new_position in [i[0] for i in old_positions]:  # если полученная позиция уже есть в списке [позиция1, позиция2]
        return False  # то она неуникальна
    else:
        return True  # если позиции в списке нет - она уникальна


n = int(input())  # кол-во строк с заказами "покупатель товар количество",


buyers = dict()  # в этот словарь буду вносить {покупатель: [[позиция, кол-во]]}
for _ in range(n):  # цикл по всем позициям
    # создаю список из заказа, если полученный элемент списка, на основе строки число - делаю его типом int (для сложения кол-ва для неуникальных позиций заказа)
    order = [int(i) if i.isdigit() else i for i in input().split()]
    # вызываю функцию на проверку, встречалась ли данная позиция с аргументами - (все существующие позиции, новая позиция)
    if is_position_unic(buyers.get(order[0], False), order[1]):  # черезе get получаю значение позиций конкретного покупателя, если покупателя нет - возвращается false (позиция уникальна),
        # если позиция оказалась уникальной - в словарь добавляю имя покупателя и в список с позициями добавляю список [товар, кол-во]
        buyers.setdefault(order[0], []).append(list(order[1:]))  # через setdefault получаю значение по ключу и прибавляю спсок, если значения нет - пустой список, к которому так-же прибавляю список
    else:  # если позиция неуникальна - то недобавляю новый список, ищу существующую и добавляю к ней новое кол-во
        for lst in buyers[order[0]]:  # запускаю цикл по всем позициям покупателя
            if order[1] == lst[0]:  # если нахожу нужную позиция, то для кол-во неуникальной позиции делаю значение - старое кол-во + новое кол-во
                lst[1] += order[2]

for i in sorted(buyers):  # по отсортированному списку имен, из словаря вывожу имя и двоеточие без пробела
    print(i, ':', sep='')
    buyers[i] = dict(buyers[i])  # в списке позиция имею конструкцию список списков [[товар1, кол-во1], [товар2, кол-во2]], на основе этой конструкции делаю словарь {товар1: кол-во1, товар2: кол-во2}
    for j in sorted(buyers[i]):  # по отсортированному списку позиций покупателя вывожу позицию и из словаря и вложенного словаря вывожу по ключу покупатель, и по второму лючу позиция - кол-во товара
        print(f'{j} {buyers[i][j]}')


# Библиотека String
import string

print(string.ascii_letters)  # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.ascii_uppercase)  #ABCDEFGHIJKLMNOPQRSTUVWXYZ
print(string.ascii_lowercase)  #abcdefghijklmnopqrstuvwxyz
print(string.digits)  #0123456789
print(string.hexdigits)  #0123456789abcdefABCDEF
print(string.octdigits)  #01234567
print(string.punctuation)  #!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
print(string.printable)  # 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ \t\n\r\x0b\x0c

# Библиотека random
random.seed(x)  # позволяет установить конкретное случайно значение, если выполнить код с выводом случайного числа и установленным сидом x - то последовательность повториться
random.radint(a, b)  # принимает два обязательных аргумента a и b и возвращает число из отрезка a b включительно, и возвращает
random.randrange(a, b)  # Принимает a, b и возвращает из отрезка от a до b не включительно (работает как range()), может принимать третий аргумент - шаг
random.random()  # возвращает случайное число с плавающей точкой от 0 до 1 включительно
random.uniform(1.1, 12.3)  # возвращает случайно число с плавающей точкой в диапазоне
random.shuffle([1, 2, 3])  # принимает в качестве аргумента список и перемешивает его случайным образом
random.choice([1, 2, 3])  # принимает список (или строку) и возвращает случайный элемент
random.sample([1, 2, 3], 2)  # принимает список (строку) и количество элементов. возвращает список случайных элементов в указанном кол-ве


# Модуль decimal
# Настраиваемый, незменяймый тип данных для точных вычислений
# нужен для решения экономических, математических и финансовых задачи, где важна максимальая точность вычислений
# создается из str и int

# Модуль fractions
# библиотека для создания дробей из из целых чисел, строк на основании десятичного представления,
# из строки на основании обыкновенной дроби
# fractions.Fraction(цилитель и знаменатель/строка)
# fractions.nominator/denominator для обращения к числителю/знаменателя типа данных Fraction


# Модуль math
int()  #Округляет число в сторону нуля
round(x)  #Округляет число x до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется до ближайшего четного числа
round(x, n)  #Округляет число x до n знаков после точки
floor(x)  #Округляет число x вниз («пол»)
ceil(x)  #Округляет число x вверх («потолок»)
abs(x)  #Модуль числа x (абсолютная величина)
gcd() # Ищет наибольший общий делитель, если делителя нет - 0. Кол-во аргументов произвольное
# Корни, логарифмы, степени и факториал
sqrt(x)  #Квадратный корень числа x
pow(x, n)  #Возведение числа x в степень n
log(x)  #Натуральный логарифм числа x. Основание натурального логарифма равно числу e
log10(x)  #Десятичный логарифм числа x. Основание десятичного логарифма равно числу 10
log(x, b)  #Логарифм числа x по основанию b
factorial(n)  #Факториал натурального числа n
# Тригонометрия
degrees(x)  # Преобразует угол x, заданный в радианах, в градусы
radians(x)  #Преобразует угол x, заданный в градусах, в радианы
cos(x)  #Косинус угла x, задаваемого в радианах
sin(x)  #Синус угла x, задаваемого в радианах
tan(x)  #Тангенс угла x, задаваемого в радианах
math.pi # число пи


# 13.2 шаг 12
# https://stepik.org/lesson/362369/step/12?unit=346925
# На вход программе подается натуральное число n
# Напишите программу, которая находит наибольшую правильную несократимую дробь с суммой числителя и знаменателя равной n
import math  # функция gcd() ищет наибольшой общий делитель
import fractions

n = int(input())

# ищу числитель - циклом от половины n (n//2) не включительно и до 0 невлючительно. числитель должен быит меньше знаменателя
for i in range((n-1)//2, 0, -1):  # поэтому беру сначала наибольшее возможное число, так чтобы числитель в сумме со знаменателем давал n
    # но был меньше знаменателя
    if math.gcd(i, n - i) == 1:  # если общий делитель один числителя и знаменателя - 1 - дробь нескоратимая, иду по дробям на убывание
        print(fractions.Fraction(i, n - i))  # поэтому при первом нахождении дроби - вывожу её, дальше дроби будут меньше, а мне нужна максимальная
        break  # перываю цикл после первой найденной несокращаемой дроби


# 15.1
# ИМЕННОВАННЫЕ/ПОЗИЦИОННЫЕ АРГУМЕНТЫ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# порядок передачи аргуметов:
1. Позиционные
2. *args  # - все, что после позиционных, но перед первым именнованным аргументов (если есть именнованные парметры или **kwargs
# иначе все оставшиеся аргументы будут в *args)
3. Именнованные  # соответствуют ключевому слову, по которому переданы
4. **kwargs  # - оставшиеся именнованные аргументы, которых нет в параметрах и они идут после *args (если он есть)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

def diff(x, y):
    return x-y

# выводит одинаковый результат, в первом случае аргументы переданны, как позиционные (10, 3)
print(diff(10, 3), diff(y=3, x=10))  # во втором случае аргументы переданы как именованные (y=3, x=10)


# параметры по умолчанию
# при создании функций могут быть указаны параметры по умолчанию, если чаще всего используется фиксированное значение параметра
def create_employee(unic_id, end_date=None):
    return unic_id, end_date

# при вызове
print(create_employee('12345'))  # end_date примет дефолтное значение, указанное в параметрах функции (None)
# при вызове
print(create_employee('123', '2023-02-04'))  # end_date примет значение, переданное как аргумент, вместо дефолтного


# параметры по умолчанию ВАЖНО
# значение параметра создается единожды, при определении функции, поэтому если значение по умолчанию - изменяемы объект
# то его изменение повлияет на все последующие вызовы

print(create_employee.__defaults__)  # выводит значение аргументов по умолчанию на момент вызова



# 15.2
# *args (argumnets) и **kwargs (keyword arguments)

def my_sum(*args):  # *args позволяет получить произвольное кол-во аргументов
    print(type(args))  # tuple
    print(sum(args))  # сумма элементов коллекции


def rand_func(**kwargs):  # **kwargs позволяет получить словарь именнованных аргументов, сохранив их названия
    print(type(kwargs))  # dict
    print(kwargs)  # выовдит {имя переданного аргумента: значение, имя переданного аргумента 1: значение 1}


def my_func(a, b, *args,  **kwargs):
    print(a, b)
    print(args)
    #print(name, age)
    print(kwargs)

my_func(1, 2, 3, 4, 'Timur', age=28, job='Teacher', language='Python')

# 15.2 шаг 16
# Параметры по умолчанию
def matrix(n=1, m=None, value=0):  # если не передано n, то в матрице будет 1 строка, если не передано value, матрица заполняется нулями
    if m == None:  # если m не передано возвращается матрица n на n
        m = n
    return [[value for _ in range(m)] for _ in range(n)]



# 15.4
# ФУНКЦИИ КАК ОБЪЕКТЫ
def hello():
    print('Hello from function')

func = hello  #  присваиваем переменной func функцию hello
func()  # вызываем функцию, обращаюся к переменной, которой мы присвоили функцию ранее


# сложные генераторы
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a*x**2 + b*x + c
    return square_polynom

# в каждой переменной вызываю верхнюю функцию, которая возвращает вложенную функцию, но с уже хранящимися там переданными аргументыами
# таким образом в каждой переменной я могу для одинаковых значений a, b, c считать формулу, меняя в ней только x
f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))  # 4, так-же могу вызвать f(5), тогда посчитается формулу, с переданными в f аргументами a, b, c, но с новым x
print(g(2))  # 5
print(h(-1))  # 57
# таким образом вложенная функция использует аргументы из внешней функции для вычислений, то есть - это называется ЗАМЫКАНИЕМ


# 15.4 шаг 10
# https://stepik.org/lesson/508939/step/10?unit=501049
# Отсортировать список кортежей по среднему арифметическому кортежей

# Функция, получающая коллекцию и возвращающая его среднее арифметическое
def compare_avg(numbers):
    return sum(numbers)/len(numbers)


numbers = [(10, 10, 10), (30, 45, 56), (81, 39), (1, 2, 3), (12,), (-2, -4, 100), (1, 2, 99), (89, 9, 34), (10, 20, 30, -2), (50, 40, 50), (34, 78, 65), (-5, 90, -1, -5), (1, 2, 3, 4, 5, 6), (-9, 8, 4), (90, 1, -45, -21)]

# для встроенных функций min() max() передаю значению ключа - свою функцию, которая считает среднее арифметическое
print(min(numbers, key=compare_avg), max(numbers, key=compare_avg), sep='\n')
# таким образом для сортировки списка кортежей берется каждый кортеж, считается его среднее арифметическое и сравнивается с другими средними арифметическими кортежей



# 15.5
# map(), filter(), reduce()
# функции высшего порядка

# функциями высшего порядка называют функции, которые принимаю другую функцию как аргумент или возвращают функцию как аргумент


# MAP()
# Функция map(func, collection) - применяется для преобразования всех элементов коллекции, используя func
# в первом аргументе func передается другая функция, которая преобразует элементы

# реализация функции map()
def map(function, items):  # принимает func, по которой преобразуется каждый элемент и список элементов, которые будут преобразованы
    result = []  # пустой список, в который будут добавляться преобразованные элементы
    for item in items:
        new_item = function(item)  # преобразует элемент, использую переданную как аргумент функцию
        result.append(new_item)  # добавляет в новый список преобразованный элемент
    return result  # возвращается список, в котором содержатся преобразованный элемент

def kvadrat(x):
    return x**2     # тело функции, которая преобразует аргумент x

numbers = [1, 2, 3]
print(map(kvadrat, numbers))  # [1, 4, 9]
print(map(str, numbers))  # ['1', '2', '3']



# FILTER()
# функиця map(func, collection) принимает функция как аргумент и коллекцию, и отбирает элементы коллекции используя полученную функцию

# реализация функции filter()
def filter(function, items):  # получаем функцию, которая будет возвращать True, если элемент - прошел фильтр и False в противном случае
    result = []  # список, куда добавляются отфильтрованные элементы
    for item in items:
        if function(item):  # проверяем, проходит ли элемент фильтр
            result.append(item)  # добавляем элемент в новый список, если он прошел проверку
    return result  # возвращаем список с элементами, прошедшими проверку

def is_greater10(num):  # функция возвращает значение True если число больше 10 и False в противном случае
    return num > 10

numbers = [12, 2, -30, 48, 51, -60, 19, 10, 13]
print(filter(is_greater10, numbers))  # [12, 48, 51, 19, 13]



# REDUCE()
# функиця reduce(func, collection) аккумулирует весь список в один элемент, принимая функцию, по которой происходит аккумуляция

# реализация функции filter()
# operation - фнукция аккумулятор, по которой элементы будут аккумулироваться
# items - коллекция, элменты которой будут аккумулироваться
# initial_value - начальное значения аккумулирующего элементы
def reduce(operation, items, initial_value):  # получаю функцию, по которой буду аккумулировать, коллекцию, начальное значение
    start = initial_value  # старт = начальное значение
    for item in items:  # для каждого элемента коллекции
        # в start записываю результат функции, в которую передаю начальное значение и сам элемент коллекции
        start = operation(start, item)  # start изменяется с каждым элментом, на второй итерации в функцию передается результат первой итерации и внутри этой функции он уже является начальным значением
    return start

def add(x, y):
    return x+y

def mult(x, y):
    return x*y

numbers = [1, 2, 3, 4, 5]
print(reduce(add, numbers, 0))  # аккумулирует все элементы, используя функцию add, получается сумма всеъ элементов - 15
print(reduce(mult, numbers, 1))  # перемножает все элементы - 120


# 15.4 шаг 12
# https://stepik.org/lesson/508556/step/12?unit=500674
# вывести сумма квадратов всех элементов списка numbers
def summa_kvadratov(start, num):
    num = num**2  # элмент возводиться в квадрат
    return start + num  # квадрат элемента прибавляется к общему счетчику

numbers = [97, 42, 9, 32, 3, 45, 31, 77, -1, 11, -2, 75, 5, 51, 34, 28, 46, 1, -8, 84, 16, 51, 90, 56, 65, 90, 23, 35, 11, -10, 70, 90, 90, 12, 96, 58, -8, -4, 91, 76, 94, 60, 72, 43, 4, -6, -5, 51, 58, 60, 30, 38, 67, 62, 36, 72, 34, 82, 62, -1, 60, 82, 87, 81, -7, 57, 26, 36, 17, 43, 80, 40, 75, 94, 91, 64, 38, 72, 29, 84, 38, 35, 7, 54, 31, 95, 78, 27, 82, 1, 64, 94, 31, 29, -8, 98, 24, 61, 7, 73]

print(reduce(summa_kvadratov, numbers, 0))



# ВСТРОЕННЫЕ MAP() FILTER() REDUCE()
# map(), filter() озвращаетт объект итератор, которы может быть преобразован в список list() или другую коллекцию или перебран с помощью for


# встроенная map(func, *collections)
# -Внутри функции func необходимо вернуть новое значение
# -Функции map() можно передать несколько последовательностей.
# В этом случае в функцию обратного вызова func будут передаваться сразу несколько элементов, расположенных в последовательностях на одинаковых позициях.

# пример передачи нескольких коллекци в map():
circle_areas = [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]

# округляем числа до 1 знака после запятой
result1 = list(map(round, circle_areas, [1]*6))  # в round передаем элмент из первой коллекции и из второй с той-же позиции

# округляем числа до 1,2,...,6 знаков после запятой
result2 = list(map(round, circle_areas, range(1, 7)))  # в round передаем элмент из первой коллекции и из второй с той-же позиции

print(circle_areas)  # [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]
print(result1)  # [3.6, 5.6, 4.3, 6.2, 91.0, 32.0]
print(result2)  # [3.6, 5.58, 4.319, 6.2024, 91.01344, 32.01213]


# встроенная filter(func, collection)
# -В качестве параметра func указывается ссылка на функцию, которой будет передаваться текущий элемент последовательности.
# -Внутри функции func необходимо вернуть значение True или False
# -может принимать любой итерируемый объект (список, строку, кортеж, и т.д.)
# -Итератор используется единожды за выполнение программы, далее "ичерпывает" себя и становится пустым



# встроенная reduce(func, iterable, initializer=None)
# -для использования нужно подключение библиотеки functools
# -Если начальное значение (initializer) не установлено, то в его качестве используется первое значение из последовательности iterable
# и итерации начинаются со второй (то есть как аргументы в func передаются сразу нулевой и первый элменты,
# а не нулевой, как начальное значение и нулевой, как первое значение итерируемого объекта)



# ИТЕРАТОРЫ
# -итераторы можно обойти циклом for;
# -итератор можно преобразовать в список или кортеж, с помощью функций list() и tuple();
# -итератор можно распаковать с помощью *



# АНОНИМНЫЕ ФУНКЦИИ
# lambda список_параметров: выражение

# список_параметров – список параметров через запятую;
# выражение – значение, либо код, дающий значение.


# ПРИМЕР
f1 = lambda: 10 + 20            # функция без параметров
f2 = lambda х, у: х + у         # функция с двумя параметрами
f3 = lambda х, у, z: х + у + z  # функция с тремя параметрами

print(f1())                     # 30
print(f2(5, 10))                # 15
print(f3(5, 10, 30))            # 45


# ПРИМЕР
points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=lambda point: point[1]))             # сортируем по второму значению кортежа
print(sorted(points, key=lambda point: point[0] + point[1]))  # сортировка по сумме элементов


# ПРИМЕР
numbers = [1, 2, 3]
new_numbers1 = list(map(lambda x: x+1, numbers))              #  увеличиваем на 1
new_numbers2 = list(map(lambda x: x*2, numbers))              #  удваиваем
new_numbers3 = list(map(lambda x: x**2, numbers))             #  возводим в квадрат


# ПРИМЕР
strings = ['a', 'b', 'c']
numbers = [2, 5, 4]
multiplied_strings = list(map(lambda x, y: x*y, numbers, strings))


# ПРИМЕР
numbers = [-1, 2, -3, 4, 0, -20, 10, 30, -40, 50, 100, 90]

positive_numbers = list(filter(lambda x: x > 0, numbers))   # положительные числа


# ПРИМЕР
from functools import reduce

words = ['python', 'stepik', 'beegeek', 'iq-option']
numbers = [1, 2, 3, 4, 5, 6]

summa = reduce(lambda x, y: x + y, numbers, 0)                        # сумма всех чисел
product = reduce(lambda x, y: x * y, numbers, 1)                      # умножение всех чисел


# ТЕРНАРНЫЙ ОПЕРАТОР В АНОНИМНЫ ФУНКЦИЯХ
# значение1 if условие else значение2
# анонимные функции не могут содержать многострочных конструкций, циклов for или while

# ПРИМЕР
numbers = [-2, 0, 1, 2, 17, 4, 5, 6]
result = list(map(lambda x: 'even' if x % 2 == 0 else 'odd', numbers))
print(result)


# ПЕРЕДАЧА АРГУМЕНТОВ В АНОНИМНЫЕ ФУНКЦИИ
# как и обычные функции, анонимные поддерживают все типы передачи аргументовв
# позиционные аргументы;
# именованные аргументы;
# переменный список позиционных аргументов (*args);
# переменный список именованных аргументов (**kwargs);
# обязательные аргументы (*).


# анонимные функции могут быть вызваны так-же как и обычные
# имеют обычный тип <class 'function'>
func = lambda x: x*10
print(1+func(2)+3)     # 24

# Анонимные функции очень часто используются вместе со встроенными функциями
# map(), filter(), reduce(), sorted(), max(), min() и т.д.


# 15.7 шаг 14
dict1 = {'x': 1}
dict2 = {'y': 2}
dict3 = {'x': 3, 'y': 4}

# как парметр в функию filter() передается список словарей
# анониманя функция с параметром d, которая проверяет входит ли 'x' в переданный аргумент (переданный аргумент - словарь)
# из сформированного функцией filter итератора формируем список функцией list()
result = list(filter(lambda d: 'x' in d.keys(), [dict1, dict2, dict3]))
print(result)  # [{'x': 1}, {'x': 3, 'y': 4}]


